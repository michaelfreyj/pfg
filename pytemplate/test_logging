#!/usr/bin/env python
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import logging
import os
from pathlib import Path
import yaml


parser = ArgumentParser(
        prog="pytemplate", description="Generates a new file from a skeleton",
        usage="pytemplate [options]", epilog="For more options, ask me"
        )
parser.add_argument(
        "-f", "--file", nargs=1, dest="infile", action="store", metavar="INFILE",
        help="Uses yaml file to generate file without user interaction",
        )
parser.add_argument(
        "-o", "--outfile", nargs=1, dest="outfile", action="store", metavar="OUTFILE",
        help="specify different name for output file -- (default=title)",
        )
parser.add_argument(
        "-v", "--verbose", action="store_true", help="Verbose output",
        )
parser.add_argument(
        "-q", "--quiet", action="store_true", help="quiet output",
        )
parser.add_argument(
        "-d", "--debug", action="store_true", help="create debugging log",
        )


args = parser.parse_args()


# create logger
# create console handler and set level to debug
logger = logging.getLogger('logging-example')
ch = logging.StreamHandler()
if args.quiet == True:
    logger.setLevel(logging.CRITICAL)
    ch.setLevel(logging.CRITICAL)
elif args.verbose == True:
    logger.setLevel(logging.INFO)
    ch.setLevel(logging.INFO)
elif args.debug == True:
    logger.setLevel(logging.DEBUG)
    ch.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.WARNING)
    ch.setLevel(logging.WARNING)


# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')

logging.error('this is a non logger module')
